---
title: "Communication Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Communication Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  fig.align = "center",
  out.width = "100%",
  dpi = 150,
  warning = FALSE,
  message = FALSE
)
```

## Overview

This tutorial covers the communication analysis step, where production and sensing scores are combined to quantify cell-cell communication via metabolites.

```{r load}
library(scMetaLink)
library(Matrix)

# Load and prepare data
data(crc_example)
obj <- createScMetaLink(crc_expr, crc_meta, "cell_type")
obj <- inferProduction(obj, verbose = FALSE)
obj <- inferSensing(obj, verbose = FALSE)
```

## Understanding Communication Scores

Communication from **sender** to **receiver** via **metabolite**:

```
Sender Cell ──[Production]──▶ Metabolite ──[Sensing]──▶ Receiver Cell
     │                            │                           │
     │                            │                           │
     ▼                            ▼                           ▼
  MPP(m,s)         ----->   Comm(s->r,m)   <-----         MSC(m,r)
```

## The `computeCommunication()` Function

```{r communication}
obj <- computeCommunication(
  obj,
  method = "geometric",      # How to combine production and sensing
  min_production = 0.1,      # Minimum production threshold
  min_sensing = 0.1,         # Minimum sensing threshold
  population.size = FALSE,   # Weight by cell type abundance
  n_permutations = 100,      # Permutations for significance
  n_cores = 1,               # Parallel cores
  seed = 42,                 # Reproducibility
  verbose = TRUE
)
```

### Parameter Deep Dive

#### 1. `method`: Combining Production and Sensing

Three methods to compute communication score:

```{r method_comparison, fig.height=4, fig.width=10, fig.cap="**Figure 1: Communication Score Method Comparison.** Heatmaps showing total communication strength between cell types using different aggregation methods. Geometric mean (default) provides balanced weighting, product emphasizes strong bilateral signals, and harmonic mean penalizes imbalanced communication."}
# Run with different methods
obj_geom <- computeCommunication(obj, method = "geometric", n_permutations = 0, verbose = FALSE)
obj_prod <- computeCommunication(obj, method = "product", n_permutations = 0, verbose = FALSE)
obj_harm <- computeCommunication(obj, method = "harmonic", n_permutations = 0, verbose = FALSE)

# Compare total communication strength
par(mfrow = c(1, 3))

total_geom <- apply(obj_geom@communication_scores, c(1,2), sum)
total_prod <- apply(obj_prod@communication_scores, c(1,2), sum)
total_harm <- apply(obj_harm@communication_scores, c(1,2), sum)

image(total_geom, main = "Geometric: sqrt(PxS)", col = hcl.colors(50, "YlOrRd"),
      axes = FALSE)
image(total_prod, main = "Product: PxS", col = hcl.colors(50, "YlOrRd"),
      axes = FALSE)
image(total_harm, main = "Harmonic: 2PS/(P+S)", col = hcl.colors(50, "YlOrRd"),
      axes = FALSE)
par(mfrow = c(1, 1))
```

**Method recommendations**:

| Method | Formula | Best for |
|--------|---------|----------|
| `geometric` | $\sqrt{P \times S}$ | General use, balanced |
| `product` | $P \times S$ | Emphasizing strong bilateral signals |
| `harmonic` | $\frac{2PS}{P+S}$ | Penalizing imbalanced communication |

#### 2. `min_production` and `min_sensing`: Noise Filtering

```{r thresholds, fig.height=5, fig.width=10, fig.cap="**Figure 2: Effect of Expression Thresholds.** Higher thresholds reduce the number of detected interactions by requiring stronger production and sensing signals. Choose based on desired stringency."}
# Compare different thresholds
thresholds <- c(0.05, 0.1, 0.2, 0.3)
n_interactions <- sapply(thresholds, function(t) {
  obj_t <- computeCommunication(obj, min_production = t, min_sensing = t, 
                                n_permutations = 0, verbose = FALSE)
  sum(obj_t@communication_scores > 0)
})

barplot(n_interactions, names.arg = thresholds,
        xlab = "Threshold (min_production = min_sensing)",
        ylab = "Number of Non-zero Interactions",
        main = "Effect of Thresholds on Detected Interactions",
        col = "#64B5F6")
```

**Guidelines**:
- `0.1`: Default, moderate filtering
- `0.05`: More permissive, may include noise
- `0.2-0.3`: More stringent, for focused analysis

#### 3. `population.size`: Cell Type Abundance Weighting

When enabled, communication is weighted by cell type abundance:

$$\text{Comm}_{\text{weighted}} = \text{Comm} \times \sqrt{\frac{n_{\text{sender}}}{N} \times \frac{n_{\text{receiver}}}{N}}$$

```{r population_size}
# Compare with and without population size correction
obj_no_pop <- computeCommunication(obj, population.size = FALSE, 
                                   n_permutations = 0, verbose = FALSE)
obj_with_pop <- computeCommunication(obj, population.size = TRUE, 
                                     n_permutations = 0, verbose = FALSE)

# Total communication per cell type pair
total_no_pop <- apply(obj_no_pop@communication_scores, c(1,2), sum)
total_with_pop <- apply(obj_with_pop@communication_scores, c(1,2), sum)

cat("Without population size correction:\n")
print(round(total_no_pop[1:5, 1:5], 3))

cat("\nWith population size correction:\n")
print(round(total_with_pop[1:5, 1:5], 3))

# Show cell type sizes
cat("\nCell type counts:\n")
print(table(crc_meta$cell_type))
```

**When to use `population.size = TRUE`**:
- Tissue-level signaling analysis
- When abundant cell types should have more influence
- Comparing communication strength across tissues

**When to use `population.size = FALSE`**:
- Cell type potential analysis (independent of abundance)
- Comparing rare vs common cell types fairly

## Statistical Significance Testing

### Permutation Test

```{r permutation, fig.height=5, fig.width=8, fig.cap="**Figure 3: P-value Distribution from Permutation Test.** Histogram of p-values from 100 permutations. A uniform distribution under the null is expected; enrichment near 0 indicates true signals. Red line marks the significance threshold (p=0.05)."}
# Run with permutation test
obj <- computeCommunication(obj, n_permutations = 100, verbose = TRUE)

# Check p-value distribution
pvals <- as.vector(obj@communication_pvalues)
hist(pvals, breaks = 50, main = "P-value Distribution",
     xlab = "P-value", col = "#90CAF9", border = "white")
abline(v = 0.05, col = "red", lwd = 2, lty = 2)
text(0.1, par("usr")[4] * 0.9, "p = 0.05", col = "red")
```

### Multiple Testing Correction

Different correction methods vary in stringency. With limited permutations (as in this tutorial), p-value correction may result in zero significant interactions:

```{r correction}
# Different correction methods - show counts
obj_none <- filterSignificantInteractions(obj, adjust_method = "none")
obj_bh <- filterSignificantInteractions(obj, adjust_method = "BH")

cat("Significant interactions by correction method:\n")
cat("  No correction:", nrow(obj_none@significant_interactions), "\n")
cat("  BH correction:", nrow(obj_bh@significant_interactions), "\n")
```

**Note**: In real analysis with sufficient permutations (>1000), BH correction is recommended. For demonstration purposes with limited permutations, we use no adjustment.

## Filtering Significant Interactions

```{r filter}
# For this tutorial, use no adjustment to demonstrate the workflow
# In real analysis, use adjust_method = "BH" with more permutations
obj <- filterSignificantInteractions(
  obj,
  pvalue_threshold = 0.05,              # Significance level
  adjust_method = "none",               # Use "BH" for real analysis
  min_score = 0                         # Minimum communication score
)

# View results
cat("Total significant interactions:", nrow(obj@significant_interactions), "\n\n")
cat("Top interactions:\n")
head(obj@significant_interactions[, c("sender", "receiver", "metabolite_name", 
                                       "communication_score", "pvalue_adjusted")])
```

## Exploring Communication Results

### Communication Score Structure

```{r structure}
# The communication_scores slot is a 3D array
comm <- obj@communication_scores
cat("Dimensions: sender x receiver x metabolite\n")
cat(dim(comm), "\n")
cat("\nCell types:", dimnames(comm)[[1]], "\n")
cat("\nMetabolites (first 10):", head(dimnames(comm)[[3]], 10), "\n")
```

### Summarizing by Cell Type Pairs

```{r summarize}
# Different aggregation methods
sum_result <- summarizeCommunicationPairs(obj, aggregate_method = "sum")
mean_result <- summarizeCommunicationPairs(obj, aggregate_method = "mean")
count_result <- summarizeCommunicationPairs(obj, aggregate_method = "count")

cat("=== Sum of Communication Scores ===\n")
head(sum_result)

cat("\n=== Mean Communication Score ===\n")
head(mean_result)

cat("\n=== Number of Significant Interactions ===\n")
head(count_result)
```

### Get Communication Matrix

```{r matrix, fig.height=7, fig.width=8, fig.cap="**Figure 7: Cell-Cell Communication Matrix.** Aggregated communication strength between all cell type pairs. Rows represent senders, columns represent receivers. Clustering groups cell types with similar communication patterns."}
# Get aggregated communication matrix
comm_mat <- getCommunicationMatrix(obj, aggregate_method = "sum")

# Visualize
heatmap(comm_mat, 
        col = hcl.colors(50, "Reds"),
        scale = "none",
        main = "Cell-Cell Communication Strength")
```

## Analyzing Specific Interactions

### Top Communicating Pairs

```{r top_pairs}
sig <- obj@significant_interactions

# Top sender-receiver pairs
pair_counts <- aggregate(communication_score ~ sender + receiver, data = sig, FUN = length)
names(pair_counts)[3] <- "n_metabolites"
pair_counts <- pair_counts[order(-pair_counts$n_metabolites), ]

cat("Top communicating cell type pairs:\n")
head(pair_counts, 10)
```

### Top Metabolite Mediators

```{r top_metabolites}
# Most frequent metabolites in significant interactions
met_counts <- table(sig$metabolite_name)
met_counts <- sort(met_counts, decreasing = TRUE)

cat("Top metabolite mediators:\n")
head(met_counts, 15)
```

### Specific Pathway Focus

```{r pathway_focus, fig.height=6, fig.width=8}
# Filter for specific metabolites (e.g., amino acids)
amino_acids <- c("L-Glutamic acid", "L-Glutamine", "L-Alanine", "Glycine", 
                 "L-Serine", "L-Proline", "L-Aspartic acid")

aa_interactions <- sig[sig$metabolite_name %in% amino_acids, ]
cat("Amino acid-mediated interactions:", nrow(aa_interactions), "\n\n")

if (nrow(aa_interactions) > 0) {
  # Summarize
  aa_summary <- aggregate(communication_score ~ sender + receiver + metabolite_name, 
                          data = aa_interactions, FUN = sum)
  aa_summary <- aa_summary[order(-aa_summary$communication_score), ]
  head(aa_summary, 10)
}
```

## Advanced: Directional Analysis

### Outgoing Communication (as Sender)

```{r outgoing, fig.cap="**Figure 4: Outgoing Communication Strength.** Total communication scores for each cell type acting as a sender. Higher values indicate cell types that produce more metabolites for intercellular signaling."}
# Which cell types send the most signals?
outgoing <- aggregate(communication_score ~ sender, data = sig, FUN = sum)
outgoing <- outgoing[order(-outgoing$communication_score), ]

barplot(outgoing$communication_score, names.arg = outgoing$sender,
        las = 2, col = "#FF7043",
        main = "Outgoing Communication Strength",
        ylab = "Total Communication Score")
```

### Incoming Communication (as Receiver)

```{r incoming, fig.cap="**Figure 5: Incoming Communication Strength.** Total communication scores for each cell type acting as a receiver. Higher values indicate cell types that sense/uptake more metabolites from other cells."}
# Which cell types receive the most signals?
incoming <- aggregate(communication_score ~ receiver, data = sig, FUN = sum)
incoming <- incoming[order(-incoming$communication_score), ]

barplot(incoming$communication_score, names.arg = incoming$receiver,
        las = 2, col = "#42A5F5",
        main = "Incoming Communication Strength",
        ylab = "Total Communication Score")
```

### Net Communication Flow

```{r net_flow, fig.height=6, fig.width=8, fig.cap="**Figure 6: Net Communication Flow.** Difference between outgoing and incoming communication for each cell type. Positive values (orange) indicate net senders; negative values (blue) indicate net receivers. This reveals which cell types drive vs receive metabolic signals in the tissue."}
# Net flow = Outgoing - Incoming
cell_types <- unique(c(sig$sender, sig$receiver))
net_flow <- sapply(cell_types, function(ct) {
  out <- sum(sig$communication_score[sig$sender == ct])
  inc <- sum(sig$communication_score[sig$receiver == ct])
  out - inc
})

# Sort and plot
net_flow <- sort(net_flow, decreasing = TRUE)
cols <- ifelse(net_flow > 0, "#FF7043", "#42A5F5")

barplot(net_flow, col = cols, las = 2,
        main = "Net Communication Flow",
        ylab = "Outgoing - Incoming")
abline(h = 0, lty = 2)
legend("topright", legend = c("Net Sender", "Net Receiver"),
       fill = c("#FF7043", "#42A5F5"))
```

## Comparing Conditions (If Available)

```{r compare, eval=FALSE}
# If your data has conditions (e.g., tumor vs normal)
# You can run scMetaLink separately and compare

# Example workflow:
obj_tumor <- runScMetaLink(expr_tumor, meta_tumor, "cell_type")
obj_normal <- runScMetaLink(expr_normal, meta_normal, "cell_type")

# Compare communication strength
comm_tumor <- getCommunicationMatrix(obj_tumor)
comm_normal <- getCommunicationMatrix(obj_normal)

# Differential communication
diff_comm <- comm_tumor - comm_normal
```

## Output Summary

| Output | Description | Access |
|--------|-------------|--------|
| Communication scores | 3D array (sender x receiver x metabolite) | `obj@communication_scores` |
| P-values | 3D array of permutation p-values | `obj@communication_pvalues` |
| Significant interactions | Filtered data.frame | `obj@significant_interactions` |
| Summary matrix | 2D aggregated matrix | `getCommunicationMatrix(obj)` |
| Pair summary | data.frame by cell type pairs | `summarizeCommunicationPairs(obj)` |

## Next Steps

- **[Visualization](05-visualization.html)**: Create publication-ready figures
- **[Applications](06-applications.html)**: Real-world analysis examples
