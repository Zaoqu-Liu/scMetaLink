---
title: "Production & Sensing Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Production & Sensing Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  fig.align = "center",
  out.width = "100%",
  dpi = 150,
  warning = FALSE,
  message = FALSE
)
```

## Overview

This tutorial provides a deep dive into the production and sensing inference steps, explaining each parameter and showing how to interpret the results.

```{r load}
library(scMetaLink)
library(Matrix)

# Load example data
data(crc_example)

# Create object
obj <- createScMetaLink(crc_expr, crc_meta, "cell_type")
```

## Part 1: Metabolite Production Potential

### Understanding Production

**Production potential** reflects a cell type's capacity to:
1. **Synthesize** metabolites via enzymatic reactions
2. **Secrete/release** metabolites to the extracellular space

```{r prod_concept, echo=FALSE, fig.height=3, fig.width=8}
par(mar = c(1, 1, 2, 1))
plot(0, 0,
  type = "n", xlim = c(0, 10), ylim = c(0, 4), axes = FALSE,
  xlab = "", ylab = "", main = "Metabolite Production Components"
)

# Cell
rect(1, 0.5, 4, 3.5, col = "#E3F2FD", border = "#1976D2", lwd = 2)
text(2.5, 3.2, "Cell", font = 2)

# Enzyme
rect(1.5, 1.5, 3.5, 2.5, col = "#FFF9C4", border = "#F57F17", lwd = 2)
text(2.5, 2, "Enzyme\n(Synthesis)", cex = 0.8)

# Transporter
rect(3.8, 1.5, 4.2, 2.5, col = "#C8E6C9", border = "#388E3C", lwd = 2)

# Metabolite
points(5.5, 2, pch = 19, cex = 2, col = "#E91E63")
text(5.5, 1.3, "Metabolite", cex = 0.8)

# Arrows
arrows(3.5, 2, 3.8, 2, length = 0.1, lwd = 2)
arrows(4.2, 2, 5, 2, length = 0.1, lwd = 2)

# Labels
text(4, 2.8, "Transporter\n(Secretion)", cex = 0.7)

# Formula
text(7.5, 2, "Production = Synthesis + Secretion", font = 2, cex = 1.1)
```

### The `inferProduction()` Function

```{r production_full}
obj <- inferProduction(
  obj,
  method = "combined", # Expression scoring method
  mean_method = "arithmetic", # Mean calculation method
  min_expression = 0, # Minimum expression threshold
  min_pct = 0.1, # Minimum % of expressing cells
  consider_degradation = TRUE, # Account for degradation enzymes
  consider_secretion = TRUE, # Weight by extracellular localization
  normalize = TRUE, # Normalize across cell types
  verbose = TRUE
)
```

### Parameter Deep Dive

#### 1. `method`: Expression Scoring

```{r method_comparison, fig.height=5, fig.width=10, fig.cap="**Figure 1: Expression Scoring Method Comparison.** Lactate production potential across cell types using three different scoring methods. 'mean' uses average expression, 'proportion' uses percentage of expressing cells, and 'combined' multiplies both for a balanced score."}
# Compare different scoring methods
obj_mean <- inferProduction(obj, method = "mean", verbose = FALSE)
obj_prop <- inferProduction(obj, method = "proportion", verbose = FALSE)
obj_comb <- inferProduction(obj, method = "combined", verbose = FALSE)

# Compare for lactate
lactate_id <- "HMDB0000190"
par(mfrow = c(1, 3))

if (lactate_id %in% rownames(obj_mean@production_scores)) {
  barplot(sort(obj_mean@production_scores[lactate_id, ], decreasing = TRUE),
    las = 2, main = "method = 'mean'", col = "#64B5F6", cex.names = 0.7
  )
  barplot(sort(obj_prop@production_scores[lactate_id, ], decreasing = TRUE),
    las = 2, main = "method = 'proportion'", col = "#81C784", cex.names = 0.7
  )
  barplot(sort(obj_comb@production_scores[lactate_id, ], decreasing = TRUE),
    las = 2, main = "method = 'combined'", col = "#FFB74D", cex.names = 0.7
  )
}
par(mfrow = c(1, 1))
```

**Recommendations**:
- `combined`: Best for most cases, balances expression level and consistency
- `mean`: When you trust raw expression values
- `proportion`: When dropout is severe and you only care about on/off

#### 2. `mean_method`: Robust Mean Calculation

For single-cell data with high dropout and outliers, **trimean** provides robustness:

```{r mean_method}
# Compare arithmetic vs trimean
obj_arith <- inferProduction(obj, mean_method = "arithmetic", verbose = FALSE)
obj_trim <- inferProduction(obj, mean_method = "trimean", verbose = FALSE)

# Correlation between methods
if (nrow(obj_arith@production_scores) > 0) {
  cor_val <- cor(
    as.vector(obj_arith@production_scores),
    as.vector(obj_trim@production_scores)
  )
  cat("Correlation between arithmetic and trimean:", round(cor_val, 3), "\n")
}
```

**When to use trimean**:
- High dropout rates (>50%)
- Suspected outlier cells
- When standard mean seems unstable

#### 3. `consider_degradation`: Accounting for Metabolite Turnover

When `TRUE`, production score is adjusted by subtracting degradation enzyme expression:

$$\text{Production}_{\text{net}} = \text{Production}_{\text{raw}} - 0.5 \times \text{Degradation}$$

```{r degradation}
obj_with_deg <- inferProduction(obj, consider_degradation = TRUE, verbose = FALSE)
obj_no_deg <- inferProduction(obj, consider_degradation = FALSE, verbose = FALSE)

# See the effect
cat("With degradation adjustment:\n")
print(head(sort(obj_with_deg@production_scores["HMDB0000190", ], decreasing = TRUE)))
cat("\nWithout degradation adjustment:\n")
print(head(sort(obj_no_deg@production_scores["HMDB0000190", ], decreasing = TRUE)))
```

#### 4. `consider_secretion`: Extracellular Localization

When `TRUE`, metabolites known to be extracellular receive full weight (1.0), while intracellular metabolites are downweighted (0.5):

```{r secretion}
# Check extracellular metabolites
db <- scMetaLink:::.load_metalinksdb()
extra_mets <- unique(db$cell_location$hmdb[db$cell_location$cell_location == "Extracellular"])
cat("Number of extracellular metabolites:", length(extra_mets), "\n")
cat("Sample:", head(db$metabolites$metabolite[db$metabolites$hmdb %in% extra_mets]), "\n")
```

### Exploring Production Results

```{r explore_production}
# Get production score matrix
prod_scores <- obj@production_scores

cat("Production score matrix dimensions:", dim(prod_scores), "\n")
cat("Metabolites:", nrow(prod_scores), "\n")
cat("Cell types:", ncol(prod_scores), "\n")

# Top producing cell types for key metabolites
cat("\n=== Top Lactate Producers ===\n")
print(getTopProducers(obj, "L-Lactic acid", top_n = 5))

cat("\n=== Top ATP Producers ===\n")
print(getTopProducers(obj, "Adenosine triphosphate", top_n = 5))
```

### Visualizing Production Patterns

```{r prod_heatmap, fig.height=8, fig.width=10, fig.cap="**Figure 2: Production Potential Heatmap.** Top 30 metabolites with highest variance across cell types. Row-scaled values show relative production potential. Clustering reveals cell types with similar metabolic production profiles."}
# Heatmap of production scores for top variable metabolites
prod_var <- apply(prod_scores, 1, var)
top_mets <- names(sort(prod_var, decreasing = TRUE))[1:30]

# Simple heatmap
heatmap(prod_scores[top_mets, ],
  scale = "row",
  col = hcl.colors(50, "RdYlBu", rev = TRUE),
  margins = c(10, 15),
  main = "Production Potential (Top 30 Variable Metabolites)"
)
```

---

## Part 2: Metabolite Sensing Capability

### Understanding Sensing

**Sensing capability** reflects a cell type's capacity to:
1. **Detect** metabolites via membrane receptors (GPCRs, ion channels, etc.)
2. **Uptake** metabolites via transporters

```{r sens_concept, echo=FALSE, fig.height=3, fig.width=8}
par(mar = c(1, 1, 2, 1))
plot(0, 0,
  type = "n", xlim = c(0, 10), ylim = c(0, 4), axes = FALSE,
  xlab = "", ylab = "", main = "Metabolite Sensing Components"
)

# Metabolite
points(2, 2, pch = 19, cex = 2, col = "#E91E63")
text(2, 1.3, "Metabolite", cex = 0.8)

# Cell
rect(4, 0.5, 9, 3.5, col = "#E8F5E9", border = "#388E3C", lwd = 2)
text(6.5, 3.2, "Receiver Cell", font = 2)

# Receptor
rect(3.8, 1.5, 4.2, 2.5, col = "#FFCCBC", border = "#E64A19", lwd = 2)
text(4.5, 2.8, "Receptor", cex = 0.7)

# Transporter
rect(3.8, 0.7, 4.2, 1.3, col = "#B3E5FC", border = "#0288D1", lwd = 2)
text(4.7, 0.6, "Transporter", cex = 0.7)

# Arrows
arrows(2.5, 2.2, 3.7, 2.2, length = 0.1, lwd = 2)
arrows(2.5, 1.8, 3.7, 1, length = 0.1, lwd = 2)

# Signal
text(6.5, 2, "Intracellular\nSignaling", cex = 0.9, col = "#6A1B9A")
arrows(4.2, 2, 5.5, 2, length = 0.1, lwd = 2, col = "#6A1B9A")
```

### The `inferSensing()` Function

```{r sensing_full}
obj <- inferSensing(
  obj,
  method = "combined", # Expression scoring method
  mean_method = "arithmetic", # Mean calculation method
  min_expression = 0, # Minimum expression threshold
  min_pct = 0.1, # Minimum % of expressing cells
  weight_by_affinity = TRUE, # Weight by binding affinity
  include_transporters = TRUE, # Include uptake transporters
  use_hill = FALSE, # Apply Hill function transformation
  hill_n = 1, # Hill coefficient
  hill_Kh = 0.5, # Half-maximal threshold
  normalize = TRUE,
  verbose = TRUE
)
```

### Parameter Deep Dive

#### 1. `weight_by_affinity`: Binding Strength Weighting

When `TRUE`, receptors are weighted by their metabolite binding affinity from MetalinksDB:

```{r affinity_demo}
# Show affinity scores for a metabolite
receptors <- getMetaboliteReceptors("Adenosine", include_transporters = FALSE)
cat("Adenosine receptors with affinity scores:\n")
print(head(receptors, 10))
```

#### 2. `include_transporters`: Uptake Transporters

```{r transporters}
# Compare with and without transporters
obj_with_trans <- inferSensing(obj, include_transporters = TRUE, verbose = FALSE)
obj_no_trans <- inferSensing(obj, include_transporters = FALSE, verbose = FALSE)

cat("Metabolites detected:\n")
cat("  With transporters:", nrow(obj_with_trans@sensing_scores), "\n")
cat("  Without transporters:", nrow(obj_no_trans@sensing_scores), "\n")
```

**When to exclude transporters**: If you only want receptor-mediated signaling (not metabolic uptake).

#### 3. `use_hill`: Receptor Saturation Model

The Hill function models receptor binding saturation:

```{r hill_effect, fig.height=5, fig.width=10, fig.cap="**Figure 3: Hill Function Effect on Sensing Scores.** Left: Comparison of linear vs Hill-transformed sensing scores for a metabolite. Points below the diagonal indicate saturation at high expression levels. Right: Different Kh values affect when saturation begins - lower Kh means earlier saturation."}
# Compare linear vs Hill transformation
obj_linear <- inferSensing(obj, use_hill = FALSE, verbose = FALSE)
obj_hill <- inferSensing(obj, use_hill = TRUE, hill_n = 1, hill_Kh = 0.5, verbose = FALSE)

par(mfrow = c(1, 2))

# Find a common metabolite
common_met <- intersect(
  rownames(obj_linear@sensing_scores),
  rownames(obj_hill@sensing_scores)
)[1]

if (!is.na(common_met)) {
  plot(obj_linear@sensing_scores[common_met, ],
    obj_hill@sensing_scores[common_met, ],
    xlab = "Linear Sensing Score",
    ylab = "Hill-transformed Score",
    main = paste("Effect of Hill Function on", common_met),
    pch = 19, col = "#1976D2"
  )
  abline(0, 1, lty = 2, col = "gray")
}

# Hill parameter comparison
x <- seq(0, 1, 0.01)
plot(x, x,
  type = "l", lty = 2, col = "gray",
  xlab = "Expression", ylab = "Sensing Score",
  main = "Hill Function Parameters"
)
lines(x, x^1 / (0.3^1 + x^1), col = "blue", lwd = 2)
lines(x, x^1 / (0.5^1 + x^1), col = "red", lwd = 2)
lines(x, x^1 / (0.7^1 + x^1), col = "green", lwd = 2)
legend("bottomright",
  legend = c("Linear", "Kh=0.3", "Kh=0.5", "Kh=0.7"),
  col = c("gray", "blue", "red", "green"),
  lty = c(2, 1, 1, 1), lwd = 2
)
par(mfrow = c(1, 1))
```

**When to use Hill function**:
- You expect receptor saturation at high expression
- Modeling dose-response relationships
- Biological realism is important

### Exploring Sensing Results

```{r explore_sensing}
sens_scores <- obj@sensing_scores

cat("Sensing score matrix dimensions:", dim(sens_scores), "\n")

# Top sensing cell types
cat("\n=== Top Glutamate Sensors ===\n")
print(getTopSensors(obj, "L-Glutamic acid", top_n = 5))

cat("\n=== Top Adenosine Sensors ===\n")
print(getTopSensors(obj, "Adenosine", top_n = 5))
```

### Receptor Analysis for a Metabolite

```{r receptor_analysis}
# Get all receptors for a metabolite
cat("=== Serotonin (5-HT) Receptors ===\n")
serotonin_receptors <- getMetaboliteReceptors("Serotonin", include_transporters = TRUE)
print(serotonin_receptors)
```

---

## Part 3: Comparing Production and Sensing

### Which Cell Types are Producers vs Sensors?

```{r prod_vs_sens, fig.height=6, fig.width=8, fig.cap="**Figure 4: Cell Type Metabolic Roles.** Scatter plot comparing average production potential (x-axis) vs sensing capability (y-axis) for each cell type. Cell types above the diagonal are net sensors; those below are net producers."}
# Get common metabolites
common_mets <- intersect(
  rownames(obj@production_scores),
  rownames(obj@sensing_scores)
)

if (length(common_mets) > 0) {
  # Average production and sensing per cell type
  avg_prod <- colMeans(obj@production_scores[common_mets, ])
  avg_sens <- colMeans(obj@sensing_scores[common_mets, ])

  plot(avg_prod, avg_sens,
    xlab = "Average Production Potential",
    ylab = "Average Sensing Capability",
    main = "Cell Type Metabolic Roles",
    pch = 19, cex = 1.5, col = "#1976D2"
  )
  text(avg_prod, avg_sens, names(avg_prod), pos = 3, cex = 0.7)
  abline(0, 1, lty = 2, col = "gray")

  # Annotate quadrants
  text(max(avg_prod) * 0.9, max(avg_sens) * 0.1, "High Production\nLow Sensing",
    cex = 0.8, col = "gray40"
  )
  text(max(avg_prod) * 0.1, max(avg_sens) * 0.9, "Low Production\nHigh Sensing",
    cex = 0.8, col = "gray40"
  )
}
```

### Metabolite-Specific Roles

```{r metabolite_roles, fig.height=6, fig.width=10, fig.cap="**Figure 5: Metabolite-Specific Production and Sensing.** Comparison of lactate production (left, orange) and sensing (right, blue) across cell types. This reveals the communication axis: producers release lactate that sensors can detect or uptake."}
# For a specific metabolite, which cells produce vs sense?
met_name <- "L-Lactic acid"
met_id <- "HMDB0000190"

if (met_id %in% rownames(obj@production_scores) &&
  met_id %in% rownames(obj@sensing_scores)) {
  prod <- obj@production_scores[met_id, ]
  sens <- obj@sensing_scores[met_id, ]

  par(mfrow = c(1, 2))
  barplot(sort(prod, decreasing = TRUE),
    las = 2,
    main = paste(met_name, "- Production"),
    col = "#FF7043", cex.names = 0.7
  )
  barplot(sort(sens, decreasing = TRUE),
    las = 2,
    main = paste(met_name, "- Sensing"),
    col = "#42A5F5", cex.names = 0.7
  )
  par(mfrow = c(1, 1))
}
```

## Summary

| Step | Key Parameters | Output |
|------|----------------|--------|
| **Production** | `method`, `mean_method`, `consider_degradation` | `@production_scores` matrix |
| **Sensing** | `weight_by_affinity`, `include_transporters`, `use_hill` | `@sensing_scores` matrix |

## Next Steps

- **[Communication Analysis](communication.html)**: How to combine production and sensing
- **[Visualization](visualization.html)**: Advanced plotting options
